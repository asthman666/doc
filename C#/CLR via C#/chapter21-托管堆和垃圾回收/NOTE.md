## 从托管堆中分配资源

CLR 要求所有的对象都从**托管堆**分配。进程初始化时，CLR划出一个地址空间区域作为托管堆。

## 垃圾回收的算法

### 引用跟踪算法

引用跟踪算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象；值类型变量直接包含值类型实例。

我们将所有的引用类型变量都称为**根**。

### CLR开始GC

1. 暂停进程中的所有线程。这样可以防止线程在CLR检查期间访问对象并更改其状态。
2. CLR进入GC的**标记**阶段。在这个阶段，CLR遍历堆中的所有对象，将同步块索引字段中的一位设为0。这表明所有对象都应该删除。
3. CLR检查所有活动根，查看他们引用了哪些对象。如果一个根包含null，CLR忽略这个根并继续检查下个根。
4. 任何根如果引用了堆上的对象，CLR都会标记那个对象，也就是将该对象的同步块索引中的位设置位1。
    
    检查完毕后，堆中的对象要么已标记，要么未标记。已标记的对象不能被垃圾回收，因为至少有一个根在引用它。我们说这种对象是reachable的。未标记的对象是unreachable，因为应用程序中不存在使对象能被再次访问的根。
5. CLR知道哪些对象可以幸存，哪些可以删除后，就进入GC的**压缩**阶段。压缩意味着托管堆解决了堆的空间碎片化问题。

如果CLR在一次GC之后回收不了内存，而且进程中没有空间来分配新的GC区域，就说明该进程的内存已耗尽。此时，试图分配更多的内存的 `new` 操作符会抛出 `OutOfMemoryException`。应用程序可捕捉该异常并从中恢复。但大多数应用程序都不会这么做，相反，异常会成为未处理的异常，Windows将终止进程并回收进程使用的全部内存。

## 代： 提升性能

CLR的GC是基于代的垃圾回收器，它基于以下几点假设：
* 对象越新，生存期越短
* 对象越老，生存期越长
* 回收堆的一部分，速度快于回收整个堆

托管堆只支持三代：第0代，第1代和第2代。CLR初始化时，会为每一代选择预算。然而，CLR的垃圾回收器是自调节的，如果垃圾回收器发现在回收0代后存活下来的对象很少，就可能减少第0代的预算，另一方面，如果垃圾回收器收了第0代，发现还有很多对象存活，没有多少内存被回收，就会增大第0代的预算。
