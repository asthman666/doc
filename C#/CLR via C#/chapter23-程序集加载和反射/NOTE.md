# 程序集加载和反射

## JIT 编译器将方法的IL 代码编译成本机代码时，加载Assembly的过程

* 查看IL 代码中引用了哪些类型。JIT 编译器利用程序集的 TypeRef 和 AssemblyRef 元数据表来确定哪一个程序集定义了所引用的类型。
* 在AssemblyRef与数据表的记录项中，爸喊了构成程序集强命名的各个部分。JIT编译器获取所有这些部分，包括名称，版本，语言文火和公匙标记，并把他们链接成一个字符串
* JIT编译器尝试将与该标识匹配的程序集加载到AppDomain中

在内部，CLR 使用 System.Reflection.Assembly 类的静态 Load 方法尝试加载程序集到 AppDomain 中。

Load 导致CLR 向程序集应用一个版本绑定重定向策略，并在[GAC](https://docs.microsoft.com/en-us/dotnet/framework/app-domains/gac) 中查找程序集。如果没有找到，就接着去应用程序的基目录，私有路径子目录和codebase位置查找。如果调用的时候传递的是弱命名程序集，Load就不会向程序集应用版本绑定重定向策略，CLR也不会去GAC查找程序集。

## 使用反射构建动态可扩展应用程序

* 如果类库需要理解类型的定义才能提供丰富的功能，就适合使用反射。例如，FCL的序列化机制就是利用反射来判断类型定义了哪些字段

* 在运行时，当应用程序需要从特定程序集中加载特定类型以执行特定任务时，也要用反射

## 反射的性能

* 反射造成编译时无法保证类型安全。由于反射严重依赖字符串，所以会丧失编译时的类型安全性。

* 反射速度慢。使用反射时，类型及其成员的名称在编译时未知，你要用字符串名称标识每个类型及其成员，然后在运行时发现它们。